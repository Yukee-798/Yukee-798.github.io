{"meta":{"title":"Hi, MoMo！","subtitle":"","description":null,"author":"Yukee","url":"https://yukee-798.github.io","root":"/"},"pages":[{"title":"分类","date":"2021-02-14T15:03:03.000Z","updated":"2021-02-14T15:07:57.000Z","comments":true,"path":"categories/index.html","permalink":"https://yukee-798.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-03-14T16:01:49.225Z","updated":"2021-02-24T11:50:09.000Z","comments":true,"path":"self/Kimbiedark.css","permalink":"https://yukee-798.github.io/self/Kimbiedark.css","excerpt":"","text":"/* Name: Kimbie (dark) Author: Jan T. Sott License: Creative Commons Attribution-ShareAlike 4.0 Unported License URL: https://github.com/idleberg/Kimbie-highlight.js */ /* 新添加的内容 */ /* ------------------------------------- */ /* 代码框背景色和字体顔色,与hljs一样就行 */ /* 必须配置(把下面.hljs的color和background复製到这里来) */ #article-container pre, #article-container figure.highlight { background: #221a0f; color: #d3af86 } /* 代码框工具栏 (如果你关掉了copy、lang和shrink,可不用配置这个 */ #article-container figure.highlight .highlight-tools { color: #fff; background: #321a0f } /* 代码框行数(如果已经关掉line_number,可以不用配置这个) */ #article-container figure.highlight .gutter pre { background-color: #221a0f; color: #fff } /* 代码块figcaption配置(hexo自带标签https://hexo.io/zh-tw/docs/tag-plugins.html#Code-Block) */ /* 不需要可以不用配置这个 */ #article-container figure.highlight figcaption, #article-container figure.highlight figcaption a { color: #d3af86 !important } /* 代码框滚动条 (需要可配置，默认为主题主顔色）*/ /* 不需要可以不用配置这个 */ #article-container figure.highlight table::-webkit-scrollbar-thumb { background: #d3af86 !important } /* Kimbie Comment */ .hljs-comment, .hljs-quote { color: #d6baad; } /* Kimbie Red */ .hljs-variable, .hljs-template-variable, .hljs-tag, .hljs-name, .hljs-selector-id, .hljs-selector-class, .hljs-regexp, .hljs-meta { color: #dc3958; } /* Kimbie Orange */ .hljs-number, .hljs-built_in, .hljs-builtin-name, .hljs-literal, .hljs-type, .hljs-params, .hljs-deletion, .hljs-link { color: #f79a32; } /* Kimbie Yellow */ .hljs-title, .hljs-section, .hljs-attribute { color: #f06431; } /* Kimbie Green */ .hljs-string, .hljs-symbol, .hljs-bullet, .hljs-addition { color: #889b4a; } /* Kimbie Purple */ .hljs-keyword, .hljs-selector-tag, .hljs-function { color: #98676a; } .hljs { display: block; overflow-x: auto; background: #221a0f; color: #d3af86; padding: 0.5em; } .hljs-emphasis { font-style: italic; } .hljs-strong { font-weight: bold; }"}],"posts":[{"title":"Taro Notes","slug":"Taro-Notes","date":"2021-03-11T10:30:07.000Z","updated":"2021-03-11T10:30:25.000Z","comments":true,"path":"2021/03/11/Taro-Notes/","link":"","permalink":"https://yukee-798.github.io/2021/03/11/Taro-Notes/","excerpt":"","text":"","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://yukee-798.github.io/tags/Web/"},{"name":"Taro","slug":"Taro","permalink":"https://yukee-798.github.io/tags/Taro/"}]},{"title":"Redux-Saga","slug":"Redux-Saga","date":"2021-03-07T09:46:58.000Z","updated":"2021-03-07T14:35:11.000Z","comments":true,"path":"2021/03/07/Redux-Saga/","link":"","permalink":"https://yukee-798.github.io/2021/03/07/Redux-Saga/","excerpt":"","text":"redux-saga 的基本概念redux-saga 是一个用于管理应用程序 Side Effect 副作用 (例如：异步操作等) 的第三方库，它的目的是让 Side Effect 管理更加的简单，执行更加高效。 redux-saga 就是 redux 的一个中间件，可以通过 redux action 从主应用程序中启动、暂停和取消 它可以访问 redux 中的 allStates 它可以 dispacth redux action 对比 redux-thunk，其的作用是在 dispatch 一个函数的时候，让 store 不要分发给 reducer 而是去执行这个函数。redux-saga 使用了 ES6 的 Generator 功能，让异步流程更加易于读取、写入和测试，通过这种方式，让异步看起来更像标准同步的 JavaScript 代码 (有点像 async/await) 合并 sagas 并连接 saga 与 store文件目录结构 123456789101112|- /node_modules|- /public|- /src |- /pages |- /store |- /actions |- /reducers |- /sagas |- helloSaga.ts |- defSaga.ts |- rootSaga.ts |- index.ts /src/store/sagas/helloSaga.ts 123export default function* helloSaga() &#123; console.log(&#x27;Hello Sagas!&#x27;);&#125; /src/store/sagas/defSaga.ts 12345678export default function* watchIncrementAsync() &#123; yield takeEvery(&#x27;INCREMENT_ASYNC&#x27;, incrementAsync)&#125;function* incrementAsync() &#123; yield delay(1000) yield put(&#123;type: &#x27;INCREMENT&#x27;&#125;)&#125; 接下来合并上面的两个 saga 到 rootSaga.ts 文件中 /src/store/sagas/rootSaga.ts 123456export default function* rootSaga () &#123; yield all([ helloSaga(), watchIncrementAsync() ])&#125; /src/store/index.ts 在 index.ts 文件中引入 rootSaga.ts 和用于创建 saga 中间件的函数 createSagaMiddleware。分别调用 createSagaMiddleware 和 applyMiddleware 来将 store 和 saga 关联起来。 1234567891011121314import &#123;createStore, applyMiddleware&#125; from &#x27;redux&#x27;import homeReducer from &#x27;./reducers/index&#x27;import rootSaga from &#x27;./sagas/rootSaga.js&#x27;import createSagaMiddleware from &#x27;redux-saga&#x27;// 创建 saga 中间件const sagaMiddleware = createSagaMiddleware()// 应用 saga 中间件到 redux 中export default createStore( homeReducer,applyMiddleware(sagaMiddleware))// 该代码用来执行一次 saga 生成器函数(从头到尾跑一遍函数体内部代码)sagaMiddleware.run(rootSaga) 使用 saga 发起异步调用12345678910111213import &#123; delay &#125; from &#x27;redux-saga&#x27;import &#123; put, takeEvery &#125; from &#x27;redux-saga/effects&#x27;// Our worker Saga: 将执行异步的 increment 任务export function* incrementAsync() &#123; yield delay(1000) yield put(&#123; type: &#x27;INCREMENT&#x27; &#125;)&#125;// Our watcher Saga: 在每个 INCREMENT_ASYNC action spawn 一个新的 incrementAsync 任务export function* watchIncrementAsync() &#123; yield takeEvery(&#x27;INCREMENT_ASYNC&#x27;, incrementAsync)&#125; watchIncrementAsync 用于监听 INCREMENT_ASYNC 描述的 action，监听到后会执行回调 incrementAsync。 incrementAsync 也是一个 saga，它会 yield 对象到 redux-saga middleware 中， 被 yield 的对象都是一类指令，指令可被 middleware 解释执行。当 middleware 取得一个 yield 后的 Promise，middleware 会暂停 Saga，直到 Promise 完成。 在上面的例子中，incrementAsync 这个 Saga 会暂停直到 delay 返回的 Promise 被 resolve，这个 Promise 将在 1 秒后 resolve。一旦 Promise 被 resolve，middleware 会恢复 Saga 接着执行，直到遇到下一个 yield。 简单来说： saga 函数 yield 的对象为 promise 对象。 该 promise 对象会被 middleware 解释执行，此时 middleware 会暂停 saga 函数继续往下执行。 只有当这个 promise 完成后，saga 函数才会继续往下执行。 delay 工具函数的作用是返回一个延迟 1 秒再 resolve 的 promise 对象，我们将使用这个函数去 block(阻塞) Generator。在这个例子中，下一个语句是另一个被 yield 的 promise 对象：调用 put(&#123;type: &#39;INCREMENT&#39;&#125;) 的结果，意思是告诉 middleware 发起一个 INCREMENT 的 action。 put 就是我们称作 Effect 的一个例子。Effects 是一些简单 Javascript 对象，包含了要被 middleware 执行的指令。 当 middleware 拿到一个被 saga yield 的 Effect，它会暂停 saga，直到 Effect 执行完成，然后 saga 会再次被恢复。 简单来说： delay 是 redux-saga 中的工具函数，用于阻塞 saga 函数。 put 的作用是告诉 middleware 发起一个 action。 接下来，我们创建了另一个 saga watchIncrementAsync。我们用了一个 redux-sag提供的辅助函数takeEvery，用于监听所有的 INCREMENT_ASYNCaction，并在 action 被匹配时执行incrementAsync` 任务。 saga 辅助函数 takeEvery(pattern, saga, …args) takeLatest(pattern, saga, …args) throttle(ms, pattern, saga, …args) 参数解释： pattern：表示监听的 action type saga：一个 saga 回调函数 args：回调 saga 时传入的参数 共有特性： 在组件中 dispatch 对应的异步 action，会被 saga 函数内的辅助函数监听到，此时会执行 saga 回调。 独立的特性： 辅助函数 解释 takeEvery 触发了多少次异步 action，就会执行多少次异步任务 takeLatest 每次新触发的异步 action 会取消掉上一次正在执行的异步任务 throttle 首次监听会执行异步 action，在 ms 结束后只会执行第二次触发的异步任务 例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import &#123; call, select, takeEvery, takeLatest, throttle,&#125; from &#x27;redux-saga/effects&#x27;import axios from &#x27;axios&#x27;import &#123;TAKEEVERY, TAKELATEST, THROTTLE&#125; from &#x27;../constant&#x27;export default function* defSaga() &#123; yield takeEvery(TAKEEVERY, takeEveryCallback) yield takeLatest(TAKELATEST, takeLatestCallback) yield throttle(2000, THROTTLE, throttleCallback)&#125;function* takeEveryCallback() &#123; const res = yield call(axios.get, &#x27;https://cnodejs.org/api/v1/topics&#x27;, &#123; params: &#123; page: 1, limit: 10 &#125; &#125;) console.log(&#x27;takeEvery&#x27;, res);&#125;// 当 takeLatest 不断的监听到 TAKELATEST action// 此时会不断的调用 takeLatestCallback 这个 saga 函数，并且执行 yield call(axios.get, &#x27;https://cnodejs.org/api/v1/topics&#x27; 这行代码// 如果在下一次调用 takeLatestCallback 之前，上一次执行 callback 的所 yield 到 middleware 中的 Promise 执行完毕，则说明执行完了整个 takeLatestCallback，就不会被新调用的取消执行后面的代码执行，否则会被取消执行// 意思就是每次请求都是执行了的，但是在你下次请求前如果返回了结果即 Promise resolve 了，那么会执行下面的代码// 如果进行了下次请求，但是上一次的 Promise 并没有 resolve 则会停止上一次请求后代码的执行function* takeLatestCallback() &#123; const res = yield call(axios.get, &#x27;https://cnodejs.org/api/v1/topics&#x27;, &#123; params: &#123; page: 1, limit: 10 &#125; &#125;) console.log(&#x27;takeLatest&#x27;, res);&#125;// 第一次请求，会启动 Promise 执行// 第二次请求为所设置的 ms 内第一次请求后的第二次请求，ms 结束后执行该请求// 最多在 ms 内只有两次请求，其余请求都不会执行function* throttleCallback() &#123; const res = yield call(axios.get, &#x27;https://cnodejs.org/api/v1/topics&#x27;, &#123; params: &#123; page: 1, limit: 10 &#125; &#125;) console.log(&#x27;throttle&#x27;, res);&#125; 常用的 Effect 创建器以下 effect 创建器都是在 saga 函数中使用的。 Effect创建器函数 说明 select(selector, ...args) 获取 redux 中保存的状态，如果调用 select 参数为空(即 yield select())，那么会返回 redux 中的 allStates call(fn, ...args) 命令 middleware以参数 args 调用 fn take(pattern) 阻塞 saga，匹配到相应 action 时停止阻塞 saga put(action) 命令 middleware 向 store 发起一个 action，这个 effect 是非阻塞的","categories":[],"tags":[{"name":"Redux-Saga","slug":"Redux-Saga","permalink":"https://yukee-798.github.io/tags/Redux-Saga/"}]},{"title":"VScode指南","slug":"VScode指南","date":"2021-03-06T13:39:59.000Z","updated":"2021-03-11T04:07:04.000Z","comments":true,"path":"2021/03/06/VScode指南/","link":"","permalink":"https://yukee-798.github.io/2021/03/06/VScode%E6%8C%87%E5%8D%97/","excerpt":"","text":"快捷键记录 快捷键 说明 option + command + Z 返回撤销 option + shift + A 注释选中代码 command + shift + K 删除行 command + shift + ➡️ 选取行 command + D 选取最近的相同变量 command + shift + L 选取所有与当前选中内容相同的部分 command + U 撤销上次光标选取 command + G 找查下一个 command + shift + G 找查上一个 command + W 关闭当前文件 Debug TypeScript 配置12$ npm i typescript -D$ npm i node-ts -D 配置 tsconfig.json 123456789101112&#123; &quot;compilerOptions&quot;: &#123; &quot;module&quot;: &quot;commonjs&quot;, &quot;target&quot;: &quot;es5&quot;, &quot;noImplicitAny&quot;: true, &quot;sourceMap&quot;: true &#125;, &quot;include&quot;: [ // 这里是项目中 ts 存在根目录文件夹 &quot;03_debug/**/*&quot; ]&#125; 配置 .vscode/launch.json 1234567891011121314151617&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Current TS File&quot;, &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, // 这里是 node-ts 的启动文件，文件名可能随版本变动，可以去 node_modules 找 dist &quot;program&quot;: &quot;$&#123;workspaceRoot&#125;/node_modules/ts-node/dist/bin.js&quot;, &quot;args&quot;: [ &quot;$&#123;relativeFile&#125;&quot; ], &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;, &quot;protocol&quot;: &quot;inspector&quot; &#125; ]&#125; 启动 debug","categories":[],"tags":[{"name":"VScode","slug":"VScode","permalink":"https://yukee-798.github.io/tags/VScode/"}]},{"title":"regular expression","slug":"regular-expression","date":"2021-03-04T03:57:55.000Z","updated":"2021-03-04T04:19:01.000Z","comments":true,"path":"2021/03/04/regular-expression/","link":"","permalink":"https://yukee-798.github.io/2021/03/04/regular-expression/","excerpt":"","text":"common reg type reg explain phone /^1\\d&#123;10&#125;$/ 验证 11 位手机号 password /^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]&#123;8,30&#125;$/ 验证不少于 8 位且包含数字与字母的密码 email /^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$/ 验证邮箱地址","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://yukee-798.github.io/tags/Web/"},{"name":"Reg","slug":"Reg","permalink":"https://yukee-798.github.io/tags/Reg/"}]},{"title":"Sass Notes","slug":"Sass-Notes","date":"2021-03-03T07:20:26.000Z","updated":"2021-03-03T10:10:30.000Z","comments":true,"path":"2021/03/03/Sass-Notes/","link":"","permalink":"https://yukee-798.github.io/2021/03/03/Sass-Notes/","excerpt":"","text":"About Color Function Function Explain Example darken($color, $amount) darken the specific color by $amount which is between 0% and 100% darken(red, 10%) lighten($color, $amount) lighten the specific color by $amount which is between 0% and 100% lighten(black, 10%)","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://yukee-798.github.io/tags/Web/"},{"name":"Sass","slug":"Sass","permalink":"https://yukee-798.github.io/tags/Sass/"}]},{"title":"original web doubt collections","slug":"original-web-doubt-collections","date":"2021-02-28T09:01:32.000Z","updated":"2021-03-06T13:56:25.000Z","comments":true,"path":"2021/02/28/original-web-doubt-collections/","link":"","permalink":"https://yukee-798.github.io/2021/02/28/original-web-doubt-collections/","excerpt":"","text":"函数式编程数组相关的高阶函数map 返回值是一个新数组，用于修改原数组内的一些元素值，需要传入一个回调函数。 123456789const arr = [1, 2, 3, 4, 5];// 需求：将数组中的偶数*2，奇数减1，返回到一个新数组中const newArr = arr.map((current: number) =&gt; &#123; if (current % 2 === 0) &#123; return current * 2; &#125; else &#123; return current - 1; &#125;&#125;); filter 返回到是一个新数组，用于过滤出原数组中的某些元素，需要传入一个回调函数，回调函数返回 false 则当前值被过滤掉，返回 true 则留下。 1234567891011121314151617const arr = [1, 2, 3, 4, 5, 5, 1, 0];const judgeRepeat = (arr: Array&lt;number&gt;, value: number): boolean =&gt; &#123; // 记录出现次数 let times: number = 0; arr.forEach(element: number =&gt; &#123; if (element === value) times++; &#125;); // 如果出现2次及以上则为重复数字 if (times &gt;= 2) return false; else return true;&#125;// 将重复数字去除// 目标：[2, 3, 4, 0]const newArr = arr.filter((current: number) =&gt; &#123; return judgeRepeat(arr, current);&#125;); reduce 返回的是一个值，用于对整个数组进行归一(求和等操作)，需要传入一个回调函数，第一个参数是累加值，第二个参数是 current，除了传入一个回调函数外，reduce 的第二个参数为累加值的初始值。 12345const arr = [1, 2, 3, 4, 5];// 对整个数组求和const res = arr.reduce((total, current) =&gt; &#123; return total + current;&#125;, 0) template string and object propertiesWe all know that the object property name is type of string. The following two ways are ok. 1234const obj = &#123; name: &#x27;momo&#x27;, age: 18&#125;; 1234const obj = &#123; &#x27;name&#x27;: &#x27;momo&#x27;, &#x27;age&#x27;: 18&#125;; But when you use the template string as the property name you can’t directly use it. You must use double parentheses [ ] wrapped around it. 1234const obj = &#123; [`name`]: &#x27;momo&#x27;, [`age`]: 18&#125;; css selector1234// 表示 .yk-btn 类名具有 disabled 属性的元素.yk-btn[disabled] &#123; cursor: not-allowed;&#125; 1234567div &#123; // 表示 div 内层的所有子元素 &gt; * &#123; pointer-events: none; &#125;&#125; css propertybutton 的四种状态伪类 123456789101112131415// 默认状态.yk-btn &#123; // hover 状态 &amp;:hover &#123; &#125; // 鼠标点击不放 状态 &amp;:active &#123; &#125; // 松开鼠标后获取焦点 状态 &amp;:focus &#123; &#125;&#125; 删除 input / button 聚焦时默认边框 1234input:focus,button:focus &#123; outline: none;&#125; white-space 值 描述 normal 默认。空白会被浏览器忽略。 pre 空白会被浏览器保留。其行为方式类似 HTML 中的 &lt;pre&gt; 标签。 nowrap 文本不会换行，文本会在在同一行上继续，直到遇到 &lt;br&gt; 标签为止。 pre-wrap 保留空白符序列，但是正常地进行换行。 pre-line 合并空白符序列，但是保留换行符。 inherit 规定应该从父元素继承 white-space 属性的值。 text-align 值 描述 left 把文本排列到左边。默认值：由浏览器决定。 right 把文本排列到右边。 center 把文本排列到中间。 justify 实现两端对齐文本效果。 inherit 规定应该从父元素继承 text-align 属性的值。 vertical-align baseline 默认。元素放置在父元素的基线上。 sub 垂直对齐文本的下标。 super 垂直对齐文本的上标 top 把元素的顶端与行中最高元素的顶端对齐 text-top 把元素的顶端与父元素字体的顶端对齐 middle 把此元素放置在父元素的中部。 bottom 把元素的顶端与行中最低的元素的顶端对齐。 text-bottom 把元素的底端与父元素字体的底端对齐。 length % 使用 “line-height” 属性的百分比值来排列此元素。允许使用负值。 inherit 规定应该从父元素继承 vertical-align 属性的值。 opacity 值 描述 value 规定不透明度。从 0.0 （完全透明）到 1.0（完全不透明）。 inherit 应该从父元素继承 opacity 属性的值。 text-decoration 值 描述 none 默认。定义标准的文本。 underline 定义文本下的一条线。 overline 定义文本上的一条线。 line-through 定义穿过文本下的一条线。 blink 定义闪烁的文本。 inherit 规定应该从父元素继承 text-decoration 属性的值。 pointer-events 123456div &#123; // div 内层的所有子元素不会接受到鼠标事件 &gt; * &#123; pointer-events: none; &#125;&#125;","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://yukee-798.github.io/tags/Web/"}]},{"title":"Ant Design","slug":"Ant-Design","date":"2021-02-27T05:36:25.000Z","updated":"2021-03-05T07:07:16.000Z","comments":true,"path":"2021/02/27/Ant-Design/","link":"","permalink":"https://yukee-798.github.io/2021/02/27/Ant-Design/","excerpt":"","text":"重写 !important 样式场景： 自定义了一个 PhoneInput，在一个 Input 框的前面加了一个 Select 前缀，用于选择手机号前缀。在使用 Form.Item 的时候进行表单验证，将 validateStatus 设置成 error，此时会出现两个红色框，Input 外面有一层，Select 外面有一层。这显然不是我想要的，我现在需要把 Select 的红色边框弄掉。只需要在 chrome 里面查看这个组件的选择器，然后在 index.sass 中使用该选择器加上自己重写的样式即可。 123.ant-form-item-has-error .ant-select:not(.ant-select-disabled):not(.ant-select-customize-input) .ant-select-selector &#123; border-color: transparent !important;&#125; 参考：How to override !important? 表单普通的表单使用 12345678910111213141516171819202122232425262728293031323334353637383940&lt;Form className=&#x27;email-register-form&#x27; style=&#123;style&#125; initialValues=&#123;&#123; email: &#x27;&#x27;, password: &#x27;&#x27;, name: &#x27;&#x27; &#125;&#125; onValuesChange=&#123;onValuesChange&#125; onFinish=&#123;onFinish&#125; &gt; &lt;Form.Item className=&#x27;email-register-form-item email-register-email-item&#x27; name=&#x27;email&#x27; rules=&#123;[ &#123; required: true, message: &#x27;请输入邮箱&#x27;, validateTrigger: &#x27;onBlur&#x27; &#125;, (/* &#123; getFieldValue &#125; */) =&gt; (&#123; validator(_, value) &#123; const email = value as string; const reg = /^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$/; const isValid = reg.test(email); if (!isValid &amp;&amp; isEmailInputOnBlur &amp;&amp; email != &#x27;&#x27;) &#123; return Promise.reject(new Error(&#x27;邮箱地址不合法&#x27;)) &#125; return Promise.resolve(); &#125;, &#125;) ]&#125; validateTrigger=&#123;[&#x27;onChange&#x27;, &#x27;onBlur&#x27;]&#125; &gt; &lt;Input className=&#x27;email-register-input email-register-email-input&#x27; placeholder=&#x27;输入邮箱&#x27; onBlur=&#123;() =&gt; setIsEmailInputOnBlur(true)&#125; onFocus=&#123;() =&gt; setIsEmailInputOnBlur(false)&#125; /&gt; &lt;/Form.Item&gt;&lt;/Form&gt; 这里的 Input 是 antd 原生的组件，所以对于 Form.Item 里面的属性处理时是没有问题的，里面的 Input 的 value 只是单一的字符串类型，如果是自定义封装的 Input 那么里面的值就不是单一的字符串类型了，看看下面的例子。 具有自定义 Input 的表单","categories":[],"tags":[{"name":"Ant_Design","slug":"Ant-Design","permalink":"https://yukee-798.github.io/tags/Ant-Design/"}]},{"title":"React-Hook Life Cycle","slug":"React-Hook-Life-Cycle","date":"2021-02-24T06:15:47.000Z","updated":"2021-03-05T06:55:14.000Z","comments":true,"path":"2021/02/24/React-Hook-Life-Cycle/","link":"","permalink":"https://yukee-798.github.io/2021/02/24/React-Hook-Life-Cycle/","excerpt":"","text":"自定义 hook 案例以下是在复盘自定义 hook 时的一个例子，发现组件刷新的规律跟之前自己想象的不一样，下面来仔细分析一下。 App.ts 12345678910111213import React from &#x27;react&#x27;;import useURLLoader from &#x27;./hooks/useURLLoader&#x27;;function App() &#123; const [data, loading, err] = useURLLoader(&#x27;https://dog.ceo/api/breeds/image/random&#x27;); console.log(&#x27;App 刷新&#x27; ,loading); return ( &lt;div className=&quot;App&quot;&gt;&lt;/div&gt; );&#125;export default App; ./hooks/useURLLoader.ts 12345678910111213141516171819202122232425262728import &#123; useState, useEffect &#125; from &#x27;react&#x27;;import axios from &#x27;axios&#x27;;const useURLLoader = (url: string, deps: any[] = []) =&gt; &#123; const [data, setData] = useState&lt;any&gt;(null); const [loading, setLoading] = useState(true); const [err, setErr] = useState(&#x27;&#x27;); useEffect(() =&gt; &#123; console.log(&#x27;执行 useEffect 回调&#x27;, loading); axios.get(url) .then(value =&gt; &#123; console.log(&#x27;get 请求成功&#x27;, loading); setData(value.data); setLoading(false); console.log(&#x27;axios 成功请求回调执行完毕&#x27;, loading); &#125;) .catch(reason =&gt; &#123; setErr(reason.toString()); setLoading(false); &#125;) &#125;, [...deps, url]); console.log(&#x27;useURLLoader will return&#x27;, loading); return [data, loading, err];&#125;export default useURLLoader; 123456789useURLLoader will return trueApp 刷新 true执行 useEffect 回调 trueget 请求成功 trueuseURLLoader will return trueApp 刷新 trueuseURLLoader will return falseApp 刷新 falseuseEffect 回调执行完毕 true 第一次输出： useURLLoader will return true 首先进入 App 组件，此时会调用 useURLLoader ，然后在该 hook 中依次 useState 设置状态、useEffect 绑定副作用，然后在 return 前输出 useURLLoader will return true。 第二次输出： App 刷新 true 执行完 useURLLoader 后，回到 App 组件，输出 App 刷新 true。 第三次输出：执行 useEffect 回调 true 刚刚调用 useURLLoader 时，在内部绑定了副作用，现在开始回调副作用函数，输出 执行 useEffect 回调 true，然后 axios 异步发送请求 (注意：如果不再进行 then...catch... 则不会再有下面的输出了)。 第四次输出：get 请求成功 true axios 请求成功的回调，第一行输出 get 请求成功 true，然后执行下面的 setState。 第五次输出：useURLLoader will return true 由于在 axios 成功请求的回调中执行了 setState，此时会重新刷新整个 hook ，输出 useURLLoader will return true。 第六次输出：App 刷新 true 这里肯定会有点疑惑，为什么在 axios 成功请求的回调中执行了下面的代码，loading 还是 true ？ 12setData(value.data);setLoading(false); 理由就是，执行完 setData(value.data) 后会刷新一次 useURLLoader，同时刷新 App ，然后再执行完 setLoading(false) 后又会刷新一次 useURLLoader ，同时刷新 App。 第七次输出：useURLLoader will return false 跟上面的推测的一样，在 useURLLoader 的 axios 请求成功的回调中执行完了 setLoading(false)，此时刷新 useURLLoader。 第八次输出：App 刷新 false 由于 useURLLoader 刷新了，所以 App 刷新。 第九次输出： axios 成功请求回调执行完毕 在 axios 成功请求的回调内部，执行完一次 setState，刷新完所有组件后，又会返回到回调内部执行下一行代码。 结语通过这次案例分析解决了以下疑惑： (1) 自定义 hook 的 initState 会返回给使用 hook 的组件然后该组件会拿着初始值刷新，后再执行 hook 中的副作用更新 state 。 比如：hook 中 loading 初始状态为 false ，在 useEffect 中网络请求前将其更新为了 true ，使用该 hook 的组件会先拿到 loading: false ，再到 hook 中执行副作用回调更新 loading: true。 (2) 在 hook 中，每执行一次 setState 就会刷新整个 hook。 (3) 只要 hook 刷新了，那么使用该 hook 的组件也会刷新。 待补充： 类组件中的 setState 异步同步问题、函数组件中的 setState 异步同步问题 任务队列、异步相关的 (宏任务、微任务)","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://yukee-798.github.io/tags/Web/"},{"name":"React","slug":"React","permalink":"https://yukee-798.github.io/tags/React/"}]},{"title":"render props, HOC and hook","slug":"render-props, HOC-and-hook","date":"2021-02-24T04:09:28.000Z","updated":"2021-03-05T06:55:13.000Z","comments":true,"path":"2021/02/24/render-props, HOC-and-hook/","link":"","permalink":"https://yukee-798.github.io/2021/02/24/render-props,%20HOC-and-hook/","excerpt":"","text":"HOCHigher order component - 高阶组件，本质上就是一个函数，其接收一个组件作为参数，返回一个新的组件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import React from &#x27;react&#x27;;import axios from &#x27;axios&#x27;;interface ILoaderState &#123; data: any; isLoading: boolean; err: string;&#125;interface ILoaderProps &#123; data: any&#125;// 高阶组件// WarppedComponent 参数是待传入的普通组件const withLoader = &lt;P extends ILoaderState&gt;(WarppedComponent: React.ComponentType&lt;P&gt;, url: string) =&gt; &#123; return class LoaderComponent extends React.Component&lt;Partial&lt;ILoaderProps&gt;, ILoaderState&gt; &#123; state = &#123; data: null, isLoading: true, err: &#x27;&#x27; &#125; componentDidMount() &#123; axios.get(url) .then(value =&gt; &#123; this.setState(&#123; data: value.data, isLoading: false &#125;) &#125;) .catch(reason =&gt; &#123; this.setState(&#123; err: reason.toString(), isLoading: false&#125;) &#125;); &#125; render() &#123; const &#123; data, isLoading, err &#125; = this.state; return ( &lt;&gt; &#123; isLoading ? &#x27;Loading...&#x27; : err ? err : &lt;WarppedComponent &#123;...this.props as P&#125; data=&#123;data&#125; /&gt; &#125; &lt;/&gt; ) &#125; &#125;&#125;export default withLoader; 123456789101112131415import React from &#x27;react&#x27;;interface IShowResult &#123; message: string; status: string;&#125;// 普通组件const DogShow: React.FC&lt;&#123;data: IShowResult&#125;&gt; = (&#123; data &#125;) =&gt; &#123; return ( &lt;&gt; &lt;h2&gt;Dog show: &#123;data.status&#125;&lt;/h2&gt; &lt;img src=&#123;data.message&#125; /&gt; &lt;/&gt; )&#125;export default DogShow; 12345678910111213import React from &#x27;react&#x27;;import DogShow from &#x27;./component/Dogshow.ts&#x27;;import withLoader from &#x27;./component/HOC/withLoader.ts&#x27;;const App: React.FC = () =&gt; &#123; // 将普通组件传入 const WarppedDogShow = withLoader(DogShow, &#x27;https://dog.ceo/api/breeds/image/random&#x27;); return ( &lt;div&gt; &lt;WarppedDogShow /&gt; &lt;/div&gt; );&#125; 自定义 hook本质上是使用 useEffect 来监听所传入的 deps 的变化使自定义 hook 重新刷新获取数据。 1234567891011121314151617181920212223import &#123; useState, useEffect &#125; from &#x27;react&#x27;;import axios from &#x27;axios&#x27;;const useURLLoader = (url: string, deps: any[] = []) =&gt; &#123; const [data, setData] = useState&lt;any&gt;(null); const [loading, setLoading] = useState(false); const [err, setErr] = useState(&#x27;&#x27;); useEffect(() =&gt; &#123; setLoading(true); axios.get(url) .then(value =&gt; &#123; setData(value.data); setLoading(false); &#125;) .catch(reason =&gt; &#123; setErr(reason.toString()); setLoading(false); &#125;) &#125;, [...deps, url]); return [data, loading, err];&#125;export default useURLLoader; 12345678910111213import &#123; useEffect, useState &#125; from &quot;react&quot;;const useMousePosition = () =&gt; &#123; const [position, setPosition] = useState(&#123; x: 0, y: 0 &#125;); useEffect(() =&gt; &#123; document.addEventListener(&#x27;mousemove&#x27;, (e: MouseEvent) =&gt; &#123; setPosition(&#123; x: e.clientX, y: e.clientY &#125;); &#125;); &#125;, []); return position;&#125;export default useMousePosition;","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://yukee-798.github.io/tags/React/"}]},{"title":"yk-design exploitation","slug":"yk-design-exploitation","date":"2021-02-22T10:21:05.000Z","updated":"2021-03-10T07:39:17.000Z","comments":true,"path":"2021/02/22/yk-design-exploitation/","link":"","permalink":"https://yukee-798.github.io/2021/02/22/yk-design-exploitation/","excerpt":"","text":"项目搭建1$ npx create-react-app yk-design --template typescript Hello yk-designsrc/components/Hello 1234567891011121314151617import React from &#x27;react&#x27;interface IHelloProps &#123; message: string;&#125;const Hello: React.FC&lt;IHelloProps&gt; = (props) =&gt; &#123; return ( &lt;h2&gt;&#123;props.message&#125;&lt;/h2&gt; )&#125;Hello.defaultProps = &#123; message: &#x27;Hello World!&#x27;&#125;export default Hello; 要点： 使用 interface 为 props 限制类型 函数组件继承 React.FC 使用 defaultProps 为组件设置默认 props src/App.ts 12345678910111213import React from &#x27;react&#x27;;import Hello from &#x27;./components/Hello&#x27;import &#x27;./App.css&#x27;;function App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;Hello message=&#x27;Hello yk-design&#x27;/&gt; &lt;/div&gt; );&#125;export default App; Button限制 props 传入1234567891011interface BaseButtonProps &#123; className?: string; disabled?: boolean; size?: ButtonSizes; href?: string; btnType?: ButtonTypes; children?: React.ReactNode;&#125; const Button: React.FC&lt;BaseButtonProps&gt; = (props) =&gt; &#123;&#125; 使用 Button 组件传递 props 时，必须是 BaseButtonProps 中具有的属性，一般接口会有如下限制： 可选：属性名后面加上 ? 必选：属性名后面不加 ？ 可加其他 props：[key: string]: any props 中 size 和 type 只能使用 enum 中设置的12345678910enum ButtonType &#123; Link: &#x27;link&#x27;, Default: &#x27;default&#x27;&#125;enum ButtonSize &#123; Large: &#x27;lg&#x27;, Small: &#x27;sm&#x27;, Normal: &#x27;nor&#x27;&#125; 设置默认 props12345Button.defaultProps = &#123; disabled: false, btnType: ButtonTypes.Default, size: ButtonSizes.Normal&#125; 使用 classNames 第三方包拼接类名123456const classes = classNames(&#x27;btn&#x27;, &#123; [`btn-$&#123;btnType&#125;`]: btnType, [`btn-$&#123;size&#125;`]: size, &#x27;disabled&#x27;: disabled, [`$&#123;className&#125;`]: className&#125;); 第一个参数 btn 就是类名中的第一段字符串用于设置 button 的基本样式，后面的类名是否拼接上去则根据传入的 props 来决定，对应的 props 没有传入，则为 undefined 转为 boolean 为 false，那么这个类名就不会被拼接上去了。 为 Button 添加原生 button 标签和 a 标签的 props怎么添加？ 找到这两个原生标签的接口，然后继承上我们自定义 Button 的接口。 1234// 原生 button 的 props 接口type NativeButtonProps = React.ButtonHTMLAttributes&lt;HTMLElement&gt;;// 原生 a 标签的 props 接口type AnchorButtonProps = React.AnchorHTMLAttributes&lt;HTMLElement&gt;; 自定义 Button 的接口与原生接口冲突怎么办？ 原生 button 的 props 接口中有 type 属性，我们自定义 Button 的接口中也存在 type 属性，所以需要改名，将我们定义的 type 改名为 btnType。 如何把继承过来的所有属性全部设置为可选属性？ 对于原生 button 和 a 标签，其可能均还有必选属性，但是对于我们的 Button 组件来说用不着，那么有必要将这些属性全部设置为可选属性。使用 Partial 接口，将有上述需求的接口作为范型传入。 1type ButtonProps = Partial&lt;NativeButtonProps &amp; AnchorButtonProps&gt; 基于 jest 的组件测试jest 基本介绍jest 是 facebook 开发的测试库，内置在了 create-react-app 中。 github rep: https://github.com/facebook/jest 官方文档：https://www.jestjs.cn/docs/using-matchers 快速引导在项目根目录创建 jest.test.js jest.test.js 1234test(&#x27;test common matcher&#x27;, () =&gt; &#123; // 期待 2 + 2 的结果为 4 expect(2 + 2).toBe(4);&#125;); 执行测试的命令 12$ npx jest jest.test.js$ npx jest jest.test.js --watch 开启监控后，控制台如下 其他的断言 123456789101112131415161718192021test(&#x27;commonTest&#x27;, () =&gt; &#123; expect(2 + 2).toBe(4); expect(2 + 2).not.toBe(5);&#125;)test(&#x27;boolean&#x27;, () =&gt; &#123; expect(1).toBeTruthy(); expect(0).toBeFalsy();&#125;)test(&#x27;number&#x27;, () =&gt; &#123; expect(4).toBeGreaterThan(3); expect(3).toBeLessThan(4);&#125;)test(&#x27;object&#x27;, () =&gt; &#123; // 判断的是对象的内容 expect(&#123;name: &#x27;momo&#x27;&#125;).toEqual(&#123;name: &#x27;momo&#x27;&#125;); // 相当于 ===，判断的是对象的内存地址 expect(&#123;name: &#x27;momo&#x27;&#125;).toBe(&#123;name: &#x27;momo&#x27;&#125;);&#125;)","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://yukee-798.github.io/tags/React/"},{"name":"yk-design","slug":"yk-design","permalink":"https://yukee-798.github.io/tags/yk-design/"}]},{"title":"NodeJS Notes","slug":"NodeJS Notes","date":"2021-02-16T07:55:25.000Z","updated":"2021-03-05T06:53:58.000Z","comments":true,"path":"2021/02/16/NodeJS Notes/","link":"","permalink":"https://yukee-798.github.io/2021/02/16/NodeJS%20Notes/","excerpt":"","text":"NPM: Node Package ManagerNPM 简介NPM 即 Node Package Manager (Node 包管理器)，对于 Node 而言，NPM 帮助其完成了第三方模块的安装、依赖、发布等。借助 NPM，Node 与第三方模块之间形成了很好的一个生态系统。 NPM 常用命令 命令 说明 npm install &lt;Module Name&gt; [-g] 在本地或全局 安装 模块 npm uninstall &lt;Module Name&gt; [-g] 卸载 本地或全局的模块 npm update &lt;Module Name&gt; [-g] 更新 本地或全局安装的模块 npm root [-g] 查看本地或全局中模块 安装路径 npm init [-y] 在本地初始化 package.json npm run &lt;command&gt; 执行本地 package.json 中的脚本 使用 npm 命令安装模块npm 安装 Node.js 模块的语法格式如下： 12$ npm install &lt;Module Name&gt;$ npm i &lt;Module Name&gt; # 简写 以下实例，我们使用 npm 命令安装常用的 Node.js web 框架模块 express: 1$ npm install express 安装好之后，express 包就放在了工程目录下的 node_modules 目录中，因此在代码中只需要通过 require(‘express’) 的方式就好，无需指定第三方包路径。 1var express = require(&#x27;express&#x27;); 使用淘宝 NPM 镜像国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。 淘宝 NPM 镜像是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。 你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm: 1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 之后就可以通过 cnpm 命令来安装模块了： 1$ cnpm install &lt;Module Name&gt; 更多信息可以查阅：http://npm.taobao.org/。 全局安装与本地安装12$ npm install &lt;Module Name&gt; # 本地安装$ npm install &lt;Module Name&gt; -g # 全局安装 本地安装 会将安装包放在运行 npm 命令时所在的目录下的 ./node_modules 文件夹中 (没有会自动生成)。 可以通过 import 和 require() 引入本地安装的包。 无法直接在命令行中使用包自带的命令。 全局安装 会将安装包放在 /usr/local 下或者 NodeJS 的安装目录。 可以在任何路径下直接在命令行中使用包中自带的命令。 Tips: 如何在命令行中运行本地模块自带的命令？ 在 node_modules 中找到 .bin 文件夹，然后在里面找到对应的模块。 在命令行需要运行的指令前加上 ./node_modules/.bin/&lt;指令&gt;。 安装参数 参数 例子 解释 –save / -S npm install sass -S 把模块的版本信息保存到 package.json文件的dependencies字段中 (生产依赖环境) –save-dev / -D npm install sass -D 把模块的版本信息保存到 package.json文件的 devDependencies 字段中 (开发依赖环境) –save-optional / -O npm install sass -O 了解 –save-exact / -E npm install sass -E 了解 @版本号 npm install node-sass@4.14.1 安装对应版本号的包 Tips: 只在开发过程中使用到的包需要安装到开发依赖环境 npm i &lt;moduleName&gt; -D ，如：规范代码格式等第三方包。 App 发布到线上内部逻辑实现要用到的包需要安装到生成依赖环境 npm i &lt;moduleName&gt; -S 使用 package.json初始化生成 package.json 文件1$ npm init -y 脚本配置在介绍全局安装和本地安装的时候，说到了本地安装的模块如果想要在命令行中使用其命令，需要加上 ./node_modules/.bin/&lt;指令&gt; ，这样稍微有点麻烦，则可以通过配置 package.json 中的 scripts 字段。 package.json 1234567891011121314151617&#123; &quot;name&quot;: &quot;06_node&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,+ &quot;dev&quot;: &quot;./node-modules/.bin/node-sass -v&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123;&#125;, &quot;devDependencies&quot;: &#123; &quot;node-sass&quot;: &quot;^4.14.1&quot; &#125;&#125; 运行脚本 1$ npm run dev 这样就可以在命令行中简化运行本地模块命令。 NodeJS 搜索包的流程","categories":[],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://yukee-798.github.io/tags/NodeJS/"}]},{"title":"Axios Notes","slug":"Axios-Notes","date":"2021-02-16T07:54:25.000Z","updated":"2021-03-05T06:52:18.000Z","comments":true,"path":"2021/02/16/Axios-Notes/","link":"","permalink":"https://yukee-798.github.io/2021/02/16/Axios-Notes/","excerpt":"","text":"HTTP 相关HTTP 请求交互的基本过程 前台应用从浏览器端向服务器发送 HTTP 请求 (请求报文) 后台服务器接收到请求后，调度服务器应用处理请求，向浏览器端返回 HTTP 响应 (响应报文) 浏览器端接收到响应，解析显示响应体 / 调用监视回调 请求报文请求行： 包含请求类型(比如GET、POST) / URL 路径 / HTTP协议版本(HTTP/1.1) 1POST /s?ie=utf-8 HTTP/1.1 请求头： 以 key: value 的形式构成 123456# 主机名Host: apple.comCookie: name=apple# 告诉服务端请求体内容的格式 Content-type: application/x-www-form-urlencoded 或者 application/jsonUser-Agent: chrome 83 请求体： GET 请求的请求体 一定为空 ，POST 请求的请求体 可以为空也可以携带内容 12username=tom&amp;pwd=123 # urlencode 格式&#123;&quot;username&quot;: &quot;tom&quot;, &quot;pwd&quot;: &quot;123&quot;&#125; # json 格式 Tips： GET 请求的参数是直接加到域名后面的，有两种格式附加参数：param 和 query param：user/1001 ，意思是从 user 数组中返回 id 为 1001 的 user 对象，返回的是这个对象 query：user?id=1001 ，意思是从 user 数组中过滤出 id 为 1001 的 user 对象，返回的仍为数组 响应报文响应行： 包含协议版本(HTTP/1.1) 响应状态码(200) 响应状态字符串(OK) 1HTTP/1.1 200 OK 响应头： 以 key: value 的形式构成 123456# 描述响应体内容类型Content-type: text/html;charset=utf-8# 让浏览器存储 CookieSet-Cookie: BD_CK_SAM=1;charset=utf-8Content-length: 2048Content-encoding: gzip 响应体： html 文本 / json 文本 / js / css / 图片 … post 请求体参数格式当请求头为 Content-Type: application/x-www-form-urlencoded ，此时 post 请求体 参数格式为 urlencode ，如： username=tom&amp;pwd=123。 当请求头为 Content-Type: application/json ，此时 post 请求体 参数格式为 json ，如：&#123;&quot;username&quot;: &quot;tom&quot;, &quot;pwd&quot;: &quot;123&quot;&#125;。 当请求为 Content-Type: multipart/form-data ，此时请求体是用于文件上传。 常见请求方式求及其作用 请求方式 作用 GET 从服务器端获取数据，安全性低 POST 向服务器获取、添加数据，安全性更高 PUT 更新服务器端数据 DELETE 删除服务器端数据 API 的分类REST API： 发送请求进行 CRUD 操作时，由请求方式来决定 同一个请求路径可以进行多个操作，例如：GET 请求和 DELETE 请求同一个路径，是两种不同的操作 请求方式会用到 GET / POST / PUT / DELETE 非 REST API： 请求方式不决定请求的 CRUD 操作 一个请求路径只对应一个操作 一般只有 GET / POST 使用 json-server 搭建 REST 接口repo：https://github.com/typicode/json-server 1$ npm install -g json-server Create a db.json file with some data 123456789&#123; &quot;posts&quot;: [ &#123; &quot;id&quot;: 1, &quot;title&quot;: &quot;json-server&quot;, &quot;author&quot;: &quot;typicode&quot; &#125; ], &quot;comments&quot;: [ &#123; &quot;id&quot;: 1, &quot;body&quot;: &quot;some comment&quot;, &quot;postId&quot;: 1 &#125; ], &quot;profile&quot;: &#123; &quot;name&quot;: &quot;typicode&quot; &#125;&#125; Start JSON Server 1$ json-server --watch db.json 使用 Axios 请求 REST 接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;console&quot;&gt; &lt;button onclick=&quot;testGet()&quot;&gt;GET&lt;/button&gt; &lt;button onclick=&quot;testPost()&quot;&gt;POST&lt;/button&gt; &lt;button onclick=&quot;testPut()&quot;&gt;PUT&lt;/button&gt; &lt;button onclick=&quot;testDelete()&quot;&gt;DELETE&lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/axios/0.21.1/axios.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; function testGet() &#123; // 获取所有文章 axios.get(&#x27;http://localhost:3000/posts&#x27;) .then(response =&gt; &#123; console.log(response.data); &#125;); &#125; function testPost() &#123; // 添加新文章 axios.post(&#x27;http://localhost:3000/posts&#x27;, &#123; &quot;title&quot;: `TypeScript 教程`, &quot;author&quot;: &quot;yukee&quot; &#125;); &#125; function testPut() &#123; // 更新 id 为 2 的文章 axios.put(&#x27;http://localhost:3000/posts/2&#x27;, &#123; &quot;title&quot;: `Promise 教程`, &quot;author&quot;: &quot;yukee&quot; &#125;); &#125; function testDelete() &#123; // 删除 id 为 1 的文章 axios.delete(&#x27;http://localhost:3000/posts/1&#x27;); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://yukee-798.github.io/tags/Web/"},{"name":"Axios","slug":"Axios","permalink":"https://yukee-798.github.io/tags/Axios/"}]},{"title":"TypeScript notes","slug":"TypeScript-Notes","date":"2021-02-16T07:38:53.000Z","updated":"2021-03-05T06:55:11.000Z","comments":true,"path":"2021/02/16/TypeScript-Notes/","link":"","permalink":"https://yukee-798.github.io/2021/02/16/TypeScript-Notes/","excerpt":"","text":"useState在 hook 中经常使用 useState ，使用 TypeScript 时，一般情况下会自动判定返回的类型。 12// 这里自动判定 loading 为 boolean 类型const [loading, setLoading] = useState(false); 但是下面的情况，自动判定的类型不是我们想要的。 12// 自动判定为 null 类型const [data, setData] = useState(null); 我们可以自己设置返回类型。 1const [data, setData] = useState&lt;Object&gt;(null); 使用断言转换变量类型12345// data 返回的是一个 any 类型 const [data, loading, err] = useURLLoader(&#x27;https://dog.ceo/api/breeds/image/random&#x27;);// 将 data 转为自定义类型 const dogData = data as &#123;message: &#x27;string&#x27;, status: &#x27;string&#x27;&#125;; 12345interface IData &#123; message: &#x27;string&#x27;; status: &#x27;string&#x27;;&#125;const dogData = data as &#123;message: &#x27;string&#x27;, status: &#x27;string&#x27;&#125;; 不确定对象属性名称但一定要拥有该类型属性123interface IThemeProps &#123; [key: string]: &#123;color: string, backgroud: string&#125;&#125; React 中函数组件的定义123456789import React from &#x27;react&#x27; // 函数声明式写法function Heading(): React.ReactNode &#123; return &lt;h1&gt;My Website Heading&lt;/h1&gt;&#125; // 函数扩展式写法const OtherHeading: React.FC = () =&gt; &lt;h1&gt;My Website Heading&lt;/h1&gt; type 和 interface 为 React 组件的 State 和 Props 定义时使用 type 编写第三方环境定义时使用 interface 扩充 type 和 interfacetype 12345678type Told = &#123; name: string, age: number&#125;// 此时 Tnew 相当于有三个属性type Tnew = Told &amp; &#123; num: number&#125; interface 12345678interface Iold &#123; name: string; age: number;&#125;// 简单的继承语法interface Inew extends Iold &#123; num: number;&#125; Tips：interface 可以让 type 继承，type 可以让 interface 扩展 interface extends type newType = interface &amp; type 注意⚠️： type 与 interface 并集运算时，发送冲突的属性也会并集运算和为一个！ interface 让 type 继承时，发送冲突的属性不会覆盖，会直接报错！ interface 和 enuminterface 用于定义一个对象的结构 (拥有哪些属性和方法) 12345interface IStu &#123; name: string; age: number;&#125;const a: IStu = &#123;name: &#x27;momo&#x27;, age: 18&#125;; enum 用于限制一个变量的取值 12345678910enum Size &#123; Large: &#x27;large&#x27;, Small: &#x27;small&#x27;, Normal: &#x27;normal&#x27;&#125;// 变量 a 只能有下面三个取值// Size.Large// Size.Small// Size.Normalconst a: Size = Size.Large; 为函数定义接口和类型为函数定义接口 1234567891011interface IFun &#123; // 参数是两个 number 类型值，返回值为 number (a: number, b: number): number;&#125;interface IMapDispatch &#123; toPwdLoginForm?: () =&gt; void; toPhoneLoginForm?: () =&gt; void; toEmialRegisterForm?: () =&gt; void; toResetPwdForm?: () =&gt; void;&#125; 当用 IMapDispatch 继承了组件的 IBaseProps 后，调用对应的函数，会报错 Cannot invoke an object which is possibly &#39;undefined&#39; ，原因是接口中的参数是可选的，不传入这个参数的时候为 undefined，就不能进行调用了。 解决方案： 接口定义的时候把可选变为必选 调用函数的时候使用 toPwdLoginForm?.() 为函数定义类型 1type TFun = (a: number, b: number) =&gt; number; 处理表单事件12345678910111213import React from &#x27;react&#x27; const MyInput = () =&gt; &#123; const [value, setValue] = React.useState(&#x27;&#x27;) // 事件类型是“ChangeEvent” // 我们将 “HTMLInputElement” 传递给 input function onChange(e: React.ChangeEvent&lt;HTMLInputElement&gt;) &#123; setValue(e.target.value) &#125; return &lt;input value=&#123;value&#125; onChange=&#123;onChange&#125; id=&quot;input-example&quot;/&gt;&#125; 关于事件对象 e 的类型 根据回调函数来判断，onChange 就是 ChangeEvent，onClick 就是 ClickEvent 里面传入的范形根据触发回调函数的元素结点来判断，button 就是 HTMLButtonElement 例子 123const handleClick = (e: React.ClickEvent&lt;HTMLInputElement&gt;) =&gt; &#123; &#125;const handleChange = (e: React.ChangeEvent&lt;HTMLButtonElement&gt;) =&gt; &#123; &#125; ?. 简化函数判空1234const a = (onChange: any) =&gt; &#123; // 如果传入的 onChange 不为 undefined 则调用 onChange onChange?.(123);&#125;","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://yukee-798.github.io/tags/Web/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://yukee-798.github.io/tags/TypeScript/"}]},{"title":"Webpack Notes","slug":"Webpack-Notes","date":"2021-02-14T10:14:03.000Z","updated":"2021-03-05T06:54:10.000Z","comments":true,"path":"2021/02/14/Webpack-Notes/","link":"","permalink":"https://yukee-798.github.io/2021/02/14/Webpack-Notes/","excerpt":"","text":"Webpack 简介Webpack 是什么？Webpack 是一种前端资源构建工具，一个 静态模块打包器 (module bundler) 。在 Webpack 看来，前端的所有资源文件 ( js / json / css / img / sass / … ) 都会 作为模块处理 。它将根据模块的依赖关系进行静态分析，打包生成对应的 静态资源 (bundle) 。 场景： 在原生不使用任何框架的情况下，直接在 .html 文件中通过 link 引入 sass 样式文件时，浏览器并不能解析。 在 .js 文件中使用 ES6 的 import 语法等高级语法，浏览器也可能不会识别。 在上述场景下，我们需要一种工具来将这些浏览器不能识别的东西来编译为浏览器可识别的。如果我们又使用了其他浏览器不能直接编译的技术，则又需要其他的工具来进行编译。以前在没有 webpack 的时候，我们来一个个的维护这些工具是十分麻烦的，所以引入了构建工具的概念，作用是通过构建工具将这些不同技术都预处理工具全都包含进来，方便维护。 Webpack 的工作流程 入口文件：接收引入资源的文件就是入口文件 在入口文件中引入资源：import ‘xxx.scss’, import PhoneLogin ‘/components/PhoneLogin’ 此时会以入口文件为根结点形成依赖关系图，依次引入资源，形成 chunk (代码块) 对资源进行打包：通过 webpack 对不同的资源进行不同的处理 输出 (bundle) ：将打包好的资源输出 Webpack 五个核心概念 Entry：入口 (Entry) 指示 webpack 以哪个文件为入口起点开始打包，分析构建内部依赖图。 Loader：让 webpack 能 够 去 处 理 那 些 非 JavaScript 文 件 (webpack 自 身 只 理 解 JavaScript)，可以将 css、img … 等文件翻译为 web pack 可以识别的内容 Plugins：插件(Plugins)可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩， 一直到重新定义环境中的变量等。 Output：输出 (Output) 指示 webpack 打包后的资源 bundles 输出到哪里去，以及如何命名。 Mode：模式 (Mode) 指示 Webpack 使用相应模式的配置。 选项 描述 特点 development 会将 DefinePlugin 中 process.env.NODE_ENV 的值设置为 development。启用 NamedChunksPlugin 和 NamedModulesPlugin 能让代码本地调试 运行的环境 production 会将 DefinePlugin 中 process.env.NODE_ENV 的值设置为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 TerserPlugin 能让代码优化上线 运行的环境 在 React 项目中，项目根目录中的 index.js 就是入口文件，其引入了 App.jsx，然后 App.jsx 中又引入了其他的组件，这样就形成了一个树状图，从根结点开始打包，打包过程中遇到了 .scss / img … 资源则会通过 Loader 进行翻译为 webpack 可以处理的资源，在这过程中还可以通过 Plugins 来打包优化、压缩资源等功能更加强大的事情，最后形成 代码块 (bundle) ，然后通过 Output 指定这些资源输出到哪。 Webpack 初体验123$ npm init$ npm i webpack webpack-cli -g$ npm i webpack webpack-cli -D 创建文件目录结构 12345602_webpack初体验|- package.json |- index.html # 入口页面文件|- /build # webpack 打包整个项目后输出到的文件夹|- /src # 项目源代码文件夹 |- index.js # 入口文件 src/index.js 1234function add(x, y) &#123; return x + y;&#125;console.log(add(1, 2)); 开发环境指令： 12# webpack 会以 .src/index.js 为入口文件开始打包，输出到 ./build/ ，并且指定打包环境为开发环境 $ webpack ./src/index.js -o ./build/ --mode=development 生产环境指令： 12# 作用与开发环境指令相同，多了一个压缩代码的效果$ webpack ./src/index.js -o ./build/ --mode=production 执行指令生成 build/main.js 文件 1234567(() =&gt; &#123; // webpackBootstrap/*!**********************!*\\ !*** ./src/index.js ***! \\**********************/eval(&quot;function add(x, y) &#123;\\n return x + y;\\n&#125;\\n\\nconsole.log(add(1, 2));\\n\\n//# sourceURL=webpack://webpack_test/./src/index.js?&quot;);/******/ &#125;)(); 此时 webpack 就从入口文件开始编译打包了整个项目资源输出到了 build/main.js 文件中，main.js 中的文件就是浏览器可识别编译的文件了！ 在 index.html 中引入该打包后的文件。 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;hello webpack&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;./build/main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在浏览器中运行该 html 文件，则会看见控制台输出 3。 下面来试试通过 webpack 编译打包 json 文件。 123456702_webpack初体验|- package.json |- /build # webpack 打包整个项目后输出到的文件夹|- /src # 项目源代码文件夹 |- index.js # 入口文件 |- index.html # 入口页面文件+ |- data.json /src/data.json 1234&#123; &quot;name:&quot; &quot;momo&quot;, &quot;age:&quot; 18&#125; /src/index.js 123456+ import data from &#x27;./data.json&#x27; function add(x, y) &#123; return x + y; &#125; console.log(add(1, 2));+ console.log(data); 重新执行打包命令： 1$ webpack ./src/index.js -o ./build/ --mode=development 控制台输出： 123&#123;name: &quot;momo&quot;, age: 18&#125; 下面来试试通过 webpack 打包样式资源。 1234567802_webpack初体验|- package.json |- /build # webpack 打包整个项目后输出到的文件夹|- /src # 项目源代码文件夹 |- index.js # 入口文件 |- index.html # 入口页面文件 |- data.json+ |- style.css /src/index.js 1234567+ import &#x27;./style.css&#x27; import data from &#x27;./data.json&#x27; function add(x, y) &#123; return x + y; &#125; console.log(add(1, 2)); console.log(data); 重新执行打包命令： 1$ webpack ./src/index.js -o ./build/ 出现报错！ 结论： webpack 只能够编译打包 .js、.json 文件，能将 ES6 语法编译为浏览器可识别的语法。 不能编译打包 .css、.img 等文件，不能将 ES6 语法转换为 ES5 以下语法。 Webpack 开发环境的基本配置上一章节中我们知道了 webpack 能够去编译打包 .js、.json 文件，但是不能编译打包 .css、.img 等文件。本章节主要介绍如何配置 webpack 来让其能够去打包编译 .css、.img 等其他资源文件。 创建配置文件123456789 02_webpack初体验 |- package.json |- /build # webpack 打包整个项目后输出到的文件夹 |- /src # 项目源代码文件夹 |- index.js # 入口文件 |- index.html # 入口页面文件 |- data.json |- style.css+ |- webpack.config.js 配置文件的作用：当运行 wepack 指令的时候，会加载里面的配置，按照这些配置来干活。 webpack.config.js 123456789101112131415161718192021222324// resolve 用来拼接绝对路径，放置手写出错const &#123; resolve &#125; = require(&#x27;path&#x27;);module.exports = &#123; // 5个 webpack 核心配置 entry: &#x27;./src/index.js&#x27;, output: &#123; filename: &#x27;main.js&#x27;, // 输出的文件名 path: resolve(__dirname, &#x27;build&#x27;) // 这里必须是一个绝对路径，__dirname 是 nodejs 的变量，表示当前文件的目录绝对路径 &#125;, // loader 的配置 module: &#123; rules: [] &#125;, plugins: [ ], mode: &#x27;development&#x27; &#125; Tips: 所有的构建工具都是基于 nodejs 平台运行的 构建工具的配置模块化默认采用的是 commonjs 项目源代码中的模块化采用的是 ES6 语法 打包样式资源下载安装两个 loader 包： 12$ npm i css-loader -D$ npm i style-loader -D 修改配置文件： webpack.config.js 1234567891011121314151617181920212223242526const &#123; resolve &#125; = require(&#x27;path&#x27;);module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: &#x27;main.js&#x27;, path: resolve(__dirname, &#x27;build&#x27;) &#125;, module: &#123; rules: [+ &#123;+ test: /\\.css$/, // 正则匹配哪些文件：以 .css 结尾的文件+ use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;]+ &#125; ] &#125;, plugins: [ ], mode: &#x27;development&#x27; &#125; Tips: css-loader 作用是将 css 文件变成 commonjs 模块加载到 .js 文件中，里面的内容是样式字符串 style-loader 作用是在 html 文件的 head 标签内创建一个 style 标签，将 js 中的 css 样式字符串插入进去 在 use 数组中，style-loader 必须在 css-loader 前面，因为底层执行顺序是从数组尾部开始执行的 执行打包命令： 12# 由于设置了 webpack 配置文件，所以不用再指定入口文件路径、输出文件路径和模式了$ webpack 根据 webpack.config.js 中配置的入口文件形成树状图，依次打包编译资源文件，当遇到 .css 结尾的文件时，在 src/index.js 中引入的 style.css 样式文件就会被 webpack 经过 css-loader 打包编译为样式字符串输出到 build/main.js 文件中。将 build/main.js 引入到 index.html 中后，经过 style-loader 将 build/main.js 中的样式字符串解析到了 &lt;head&gt;&lt;/head&gt; 标签中的 &lt;style&gt;&lt;/style&gt; 标签内部。 上面的例子中我们修改 webpack 配置让其能够编译打包 .css 样式文件，那么怎么让其能够编译打包 .scss 样式文件呢？方法很简单，添加 webpack.config.js 配置文件中的 loader 配置，然后重新执行 webpack 命令打包编译即可。当然，配置前不要忘了下载安装 sass 和相应的 loader。 12$ npm install sass -D$ npm install sass-loader -D webpack.config.js 12345678910111213141516171819202122232425262728293031const &#123; resolve &#125; = require(&#x27;path&#x27;);module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: &#x27;main.js&#x27;, path: resolve(__dirname, &#x27;build&#x27;) &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125;,+ // 添加 sass loader+ &#123;+ test: /\\.scss$/,+ use [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;sass-loader&#x27;]+ &#125; ] &#125;, plugins: [ ], mode: &#x27;development&#x27; &#125; 打包 html 资源下载安装 plugins 包： 1$ npm install html-webpack-plugin -D 修改 webpack 配置文件： webpack.config.js 12345678910111213141516171819202122232425262728293031323334 const &#123; resolve &#125; = require(&#x27;path&#x27;); // 引入插件+ const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;); module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: &#x27;main.js&#x27;, path: resolve(__dirname, &#x27;build&#x27;) &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125;, &#123; test: /\\.scss$/, use [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;sass-loader&#x27;] &#125; ] &#125;, plugins: [+ new HtmlWebpackPlugin(&#123;+ // 复制 &#x27;./src/index.html&#x27; 文件，并自动引入打包输出的所有资源+ template: &#x27;./src/index.html&#x27;+ &#125;) ], mode: &#x27;development&#x27; &#125; 运行打包编译指令 1$ webpack 此时在输出文件夹目录 build 下除了会自动生成 main.js 还会生成一个 index.html ，其自动引入了 webpack 打包编译输出的所有资源文件，并且结构与指定的 template 路径的 html 文件一样。 打包图片资源在 index.scss 文件中通过 backgorund 引入三张图片 1234567891011121314 02_webpack初体验 |- package.json |- /build # webpack 打包整个项目后输出到的文件夹 |- /src # 项目源代码文件夹+ |- /img+ |- img1.png+ |- img2.png+ |- img3.png |- index.js # 入口文件 |- index.html # 入口页面文件 |- data.json |- style.css |- index.scss |- webpack.config.js src/index.scss 123456789101112131415.box1 &#123; width: 100px; height: 100px; background: url(&#x27;./img/img1.jpeg&#x27;) no-repeat 100%;&#125;.box2 &#123; width: 100px; height: 100px; background: url(&#x27;./img/img2.jpg&#x27;) no-repeat 100%;&#125;.box3 &#123; width: 100px; height: 100px; background: url(&#x27;./img/img3.PNG&#x27;) no-repeat 100%;&#125; 直接执行 webpack 指令，会报错，因为没有为 img 资源配置 loader，配置之前还需要下载安装两个包 url-loader 和 file-loader。 12$ npm install url-loader -D$ npm install file-loader -D 修改 webpack 配置文件： webpack.config.js 123456789101112131415161718192021222324252627282930313233343536373839 const &#123; resolve &#125; = require(&#x27;path&#x27;); const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;); module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: &#x27;main.js&#x27;, path: resolve(__dirname, &#x27;build&#x27;) &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125;, &#123; test: /\\.scss$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader, &#x27;sass-loader&#x27;] &#125;,+ &#123;+ test: /\\.(jpg|png|PNG|gif)$/,+ loader: &#x27;url-loader&#x27;,+ options: &#123;+ limit: 8 * 1024+ &#125;+ &#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: &#x27;./src/index.html&#x27; &#125;) ], mode: &#x27;development&#x27; &#125; Tips: 对 img 资源配置 loader 可以设置 options 配置 limit: 8 * 1024 表示只有图片大小 &lt; 8kb，才会被 base64 处理 (转为一段字符串) ，其余 &gt; 8kb 的图片会直接被复制过来 优点：减少请求数量 (减轻服务器压力) 缺点：图片体积会更大 (文件请求速度更慢)，所以一般只对小图片 (8kb~12kb) 进行 base64 使用 loader 的时候，加载多个 loader 可以用 use 属性，加载单个 loader 可以用 loader 属性 在上面的例子中，通过配置 url-loader 可以打包编译样式文件中引入的 img 资源文件，但是，对于在 html 文件中直接通过 &lt;img /&gt; 标签引入的图片资源的方式，这种方法没有效果。 此时需要使用 html-loader 用于专门处理 html 文件中的 &lt;img /&gt; 图片。 下载安装 html-loader 包： 1$ npm install html-loader -D 修改 webpack 配置文件： webpack.config.js 12345678910111213141516171819202122232425262728293031323334353637383940414243 const &#123; resolve &#125; = require(&#x27;path&#x27;); const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;); module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: &#x27;main.js&#x27;, path: resolve(__dirname, &#x27;./build&#x27;) &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125;, &#123; test: /\\.scss$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;sass-loader&#x27;] &#125;, &#123; test: /\\.(jpg|png|PNG|gif)$/, loader: &#x27;url-loader&#x27;, options: &#123; limit: 8 * 1024 &#125; &#125;,+ &#123;+ test: /\\.html$/,+ loader: &#x27;html-loader&#x27;+ &#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: &#x27;./src/index.html&#x27; &#125;) ], mode: &#x27;development&#x27; &#125;","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://yukee-798.github.io/tags/Web/"},{"name":"Webpack","slug":"Webpack","permalink":"https://yukee-798.github.io/tags/Webpack/"}]},{"title":"学习清单！","slug":"学习清单！","date":"2021-02-12T08:34:26.000Z","updated":"2021-02-24T01:46:01.000Z","comments":true,"path":"2021/02/12/学习清单！/","link":"","permalink":"https://yukee-798.github.io/2021/02/12/%E5%AD%A6%E4%B9%A0%E6%B8%85%E5%8D%95%EF%BC%81/","excerpt":"","text":"待沉淀的博客 超性感的React Hooks（三）：useState React setState 是异步执行还是同步执行？ 【React】406- React Hooks异步操作二三事 你真的了解ES6中的函数特性么？ 用TypeScript编写React的最佳实践 面试官: 谈一谈 HOC、Render props、Hooks React Hooks 之于 HoC 与 Render Props [译] 理解 React Render Props 和 HOC React hooks能替代HOC和render props么？ 待学习的技术 异步：Promise axios TypeScript nodejs webpack bootstarp 微信小程序 taro","categories":[],"tags":[{"name":"Plan","slug":"Plan","permalink":"https://yukee-798.github.io/tags/Plan/"}]},{"title":"React-doubt-collection","slug":"React-doubt-collection","date":"2021-02-12T08:00:10.000Z","updated":"2021-03-05T06:55:55.000Z","comments":true,"path":"2021/02/12/React-doubt-collection/","link":"","permalink":"https://yukee-798.github.io/2021/02/12/React-doubt-collection/","excerpt":"","text":"基础补充display: none如果对组件设置了 display: none 是不会卸载该组件的！其依旧停留在页面，只不过是处于 不可见且不占任何空间 的存在。 props.children在当前组件访问其闭合标签内部的内容。 12345const Father: FC&lt;IFather&gt; = (props) =&gt; &#123; return ( &lt;Child&gt;123&lt;/Child&gt; );&#125;; 123456const Child: FC&lt;IChild&gt; = (props) =&gt; &#123; return ( &#123;/* 访问闭合标签内容 */&#125; &lt;div&gt;props.children&lt;/div&gt; );&#125;; document.title可以用来设置网站名称。 document.removeEventListener传入事件、回调，用于移除该事件监听。 React Class 相关补充ContextContext 是组件间的一种通信方式，常用于「祖先组件」对「后代组件」间的通信。 场景： 有三个组件 A、B、C，B 是 A 的子组件、C 是 B 的子组件，现在需要让 A 组件直接对 C 组件传值。 创建 context 对象 1const NameContext = React.createContext(); 让 A 组件的所有后代都可以拿到 ContextValue 使用 Context.Provider 包裹子组件并传入 value 123456789101112131415161718192021import React, &#123; Component &#125; from &#x27;react&#x27;;import B from &#x27;./B&#x27;export const NameContext = React.createContext();export default class A extends Component &#123; state = &#123; name: &#x27;tom&#x27; &#125;; render() &#123; return ( &lt;div style=&#123;&#123; border: &#x27;1px solid red&#x27;, padding: &#x27;10px&#x27; &#125;&#125;&gt; &lt;h3&gt;我是A组件&lt;/h3&gt; &lt;h4&gt;我的名字叫&#123;this.state.name&#125;&lt;/h4&gt; &#123;/* 让 B 组件及其后代组件全都可以拿到 NameContext 保存的值 */&#125; &lt;NameContext.Provider value=&#123;this.state.name&#125;&gt; &lt;B /&gt; &lt;/NameContext.Provider&gt; &lt;/div&gt; ); &#125;&#125; 需要数据的后代组件接收祖先数组传来的数据 类组件使用 this.context，记得加上 contextType 静态属性。 12345678910111213141516import React, &#123;Component&#125; from &#x27;react&#x27;import &#123;NameContext&#125; from &#x27;./A&#x27;import D from &#x27;./D&#x27;export default class C extends Component &#123; static contextType = NameContext; render() &#123; return ( &lt;div style=&#123;&#123; border: &#x27;1px solid black&#x27;, padding: &#x27;10px&#x27; &#125;&#125;&gt; &lt;h3&gt;我是C组件&lt;/h3&gt; &lt;h4&gt;我从A组件拿到&#123;this.context&#125;&lt;/h4&gt; &lt;D /&gt; &lt;/div&gt; ); &#125;&#125; 函数组件使用 Context.Consumer 标签，里面是一个 js表达式 返回的就是 ContextValue 1234567891011121314151617import &#123;NameContext&#125; from &#x27;./A&#x27;const D = () =&gt; &#123; return ( &lt;div style=&#123;&#123; border: &#x27;1px solid black&#x27;, padding: &#x27;10px&#x27; &#125;&#125;&gt; &lt;h3&gt;我是D组件&lt;/h3&gt; &lt;h4&gt;我从A组件拿到 &lt;NameContext.Consumer&gt; &#123; value =&gt; value &#125; &lt;/NameContext.Consumer&gt; &lt;/h4&gt; &lt;/div&gt; )&#125;export default D; 函数组件还可以使用 useContext，传入 NameContext 对象，来获取祖先组件向 Provider 的 value 中传入的值。 123456789101112131415import &#123;useContext&#125; from &#x27;react&#x27;import &#123;NameContext&#125; from &#x27;./A&#x27;const D = () =&gt; &#123; const value = useContext(NameContext); return ( &lt;div style=&#123;&#123; border: &#x27;1px solid black&#x27;, padding: &#x27;10px&#x27; &#125;&#125;&gt; &lt;h3&gt;我是D组件&lt;/h3&gt; &lt;h4&gt;我从A组件拿到&#123;value&#125;&lt;/h4&gt; &lt;/div&gt; )&#125;export default D; Tips： 对于父组件直接传递数据给子组件一般使用 props 对于父组件传递数据给孙子组件 … 等跨越了儿子组件这种传递数据给后代的方式一般使用 context React Hooks 相关补充useRef 使用场景场景一123456789101112131415161718import React, &#123; useState, useEffect &#125; from &#x27;react&#x27;;const LikeButton: React.FC = () =&gt; &#123; const [like, setLike] = useState(0); const handleAlertClick = () =&gt; &#123; setTimeout(() =&gt; &#123; alert(&#x27;you clicked on&#x27; + like); &#125;, 1000); &#125; return ( &lt;&gt; &lt;button onClick=&#123;() =&gt; &#123;setLike(like + 1)&#125;&#125;&gt;&#123;like&#125;👍&lt;/button&gt; &lt;button onClick=&#123;handleAlertClick&gt;Alert !&lt;/button&gt; &lt;/&gt; );&#125; 有两个按钮，点击第一个按钮的时候会对 like 进行累加，点击第二个按钮会延迟 3s 弹窗 like。这里需要注意的是，当我们按下第二个按钮后，一直按第一个按钮进行 like 累加，三秒后弹窗弹出的 like 数量只是点击第二个按钮时 like 的数量。 下面来解决这个问题，使用 useRef 来保证 alert 出来的是最新的 like。 12345678910111213141516171819import React, &#123; useState, useEffect &#125; from &#x27;react&#x27;;const LikeButton: React.FC = () =&gt; &#123; const [like, setLike] = useState(0); const likeRef = useRef(0); const handleAlertClick = () =&gt; &#123; setTimeout(() =&gt; &#123; alert(&#x27;you clicked on&#x27; + likeRef.current); &#125;, 1000); &#125; return ( &lt;&gt; &lt;button onClick=&#123;() =&gt; &#123;setLike(like + 1)&#125;; likeRef.current++&#125;&gt;&#123;like&#125;👍&lt;/button&gt; &lt;button onClick=&#123;handleAlertClick&gt;Alert !&lt;/button&gt; &lt;/&gt; );&#125; 使用了上面的代码就可以实现所需效果，另外需要注意的是：组件内 xxref.current 取值发生改变不会引起组件刷新。 场景二使用 useRef 实现 componentUpadted。 123456789101112131415161718192021222324252627282930import React, &#123; useState, useEffect &#125; from &#x27;react&#x27;;const LikeButton: React.FC = () =&gt; &#123; const [like, setLike] = useState(0); const likeRef = useRef(0); const didMountRef = useRef(false); useEffect(() =&gt; &#123; if (didMountRef.current) &#123; /* 内部相当于 componentUpadted */ &#125; else &#123; didMountRef.current = true; &#125; &#125;) const handleAlertClick = () =&gt; &#123; setTimeout(() =&gt; &#123; alert(&#x27;you clicked on&#x27; + likeRef.current); &#125;, 1000); &#125; return ( &lt;&gt; &lt;button onClick=&#123;() =&gt; &#123;setLike(like + 1)&#125;; likeRef.current++&#125;&gt;&#123;like&#125;👍&lt;/button&gt; &lt;button onClick=&#123;handleAlertClick&gt;Alert !&lt;/button&gt; &lt;/&gt; );&#125; 场景三为 dom 结点设置 ref 属性，用于获取该结点对象。 在函数组件中使用useSelector自定义 hook","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://yukee-798.github.io/tags/Web/"},{"name":"React","slug":"React","permalink":"https://yukee-798.github.io/tags/React/"}]},{"title":"Promise Notes","slug":"Promise-Notes","date":"2021-02-09T06:17:41.000Z","updated":"2021-03-05T06:52:39.000Z","comments":true,"path":"2021/02/09/Promise-Notes/","link":"","permalink":"https://yukee-798.github.io/2021/02/09/Promise-Notes/","excerpt":"","text":"Promise 简介Promise 是什么？抽象表达： Promise 是一门新的技术(ES6 规范) Promise 是 JS 中进行异步编程的 新解决方案 (旧方案是单纯使用回调函数) 具体表达： 从语法上来说：Promise 是一个构造函数。 从功能上来说：promise 对象用来封装一个异步操作，并可以获取其 成功 / 失败 的结果值。 异步编程： fs 文件操作 数据库操作 AJAX 定时器 为什么要使用 Promise?绑定回调函数的方式更加灵活： 旧的方式：必须在启动异步任务之前绑定回调函数 promise：启动异步任务 -&gt; 返回 promise 对象 -&gt; 给 promise 对象绑定回调函数(甚至可以在异步任务结束后绑定多个回调函数) 支持链式调用，可以解决回调地狱问题： Promise 初体验快速引导123456789101112131415161718192021// resolve 解决 函数类型的数据 在异步任务返回成功成功结果时调用// reject 拒绝 函数类型的数据 在异步任务返回失败结果时调用const p = new Promise((resolve, reject) =&gt; &#123; // 内部执行异步操作(网络请求) if (/* 异步操作成功(请求成功) */) &#123; resolve(successMsg); // 传入参数，将 promise 对象的状态设置为 「成功」 reject(errorMsh); // 传入参数，将 promise 对象的状态设置为 「失败」 &#125;&#125;).then( // promise 对象状态为成功时的回调 (successMsg) =&gt; &#123; console.log(successMsg); &#125;, // promise 对象状态为失败时的回调 (errorMsg) =&gt; &#123; console.log(errorMsg); &#125;); 实践练习 —— 封装 fs 模块123456789101112131415161718/* 封装 fs 模块 */export function readFile(path, ) &#123; return new Promise((resolve, reject) =&gt; &#123; const fs = require(&#x27;fs&#x27;); fs.readFile(path, (err, data) =&gt; &#123; if (err) reject(err); else resolve(data); &#125;); &#125;);&#125;/* 使用 fs 模块 */import &#123; readFile &#125; from &#x27;./util&#x27;;readFile(&#x27;./willReadFile.txt&#x27;).then( data =&gt; console.log(data); err =&gt; throw err;); 实践练习 —— 封装 AJAX 请求12345678910111213141516171819202122232425262728293031323334/* 封装 AJAX */export function get(url) &#123; return new Promise((resolve, reject) =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.responseType = &#x27;json&#x27;; xhr.open(&#x27;GET&#x27;, url); xhr.send(); xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState === 4) &#123; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123; resolve(xhr.response) &#125; else &#123; reject(xhr.response); &#125; &#125; &#125; &#125;);&#125;;/* 使用模块 */import &#123; get &#125; from &#x27;./util&#x27;;const btn = () =&gt; &#123; const handleClick = () =&gt; &#123; get(&#x27;https://api.apiopen.top/getJoke&#x27;) .then( value =&gt; console.log(value), err =&gt; console.log(err) ); &#125;; return ( &lt;button onClick=&#123;handleClick&#125;&gt;发送请求&lt;/button&gt; );&#125;;export default btn; promise 对象属性介绍PromiseState前文中说过，在 构造 promise 对象时传入的函数 中，调用 resolve 则会将 promise 对象 的状态变为 成功，调用 reject 则会将 promise 对象 的状态变为 失败。这里说的状态实际上就是 promise 对象 中的属性 PromiseState ，它一共有三种可能取值： pending (未决定的) 默认值 resolved (fulfilled) rejected 另外，promise 对象 的状态改变只会有两种可能： pending 变为 resolved (调用 resolve方法 后改变) pending 变为 rejected (调用 reject方法 后改变) 并且，一个 promise 对象 只能改变一次状态，无论成功还是失败，都只会有 一个结果数据 ，成功的结果数据一般称为 value ，失败的结果数据一般称为 reason。 PromiseResultPromiseResult 是 promise 对象 中的另一个属性，其保存了异步任务 成功/失败的结果 ，即调用 resolve 或 reject 时传入的参数，它只能通过这两个方法来修改取值。 Promise 的基本流程 首先，调用 Promise 构造函数，传入一个带有 resolve 和 reject 参数的函数进去。然后，在这个函数内部进行异步操作，异步操作成功，则调用 resolve 方法，失败则调用 reject 方法。最后通过构造来的 promise 对象 调用 then 或 catch 来处理异步操作结果，最终仍会返回一个新的 promise 对象。 Promise APIPromise 构造函数Promise(excutor) &#123;&#125; excutor 函数：执行异步操作，(resolve, reject) =&gt; &#123;&#125; resolve 函数：异步操作成功时调用，会将 promise 对象 的 PromiseState 属性变为 resolved。 reject 函数：异步操作失败时调用，会将 promise 对象 的 PromiseState 属性变为 rejected。 Tips：在 new Promise(excutor) 时，会立刻同步执行 excutor 函数。 Promise.prototype.then 方法(onResolved, onRejected) =&gt; &#123;&#125; onResolved 函数：promise 对象 的 PromiseState 属性取值由 pending 变为 resolved 时的回调。 onRejected 函数：promise 对象 的 PromiseState 属性取值由 pending 变为 rejected 时的回调。 Tips：该方法调用完后会返回一个新的 promise 对象 Promise.prototype.catch 方法onRejected =&gt; &#123;&#125; 该方法只用于指定 promise 对象 的 PromiseState 属性取值由 pending 变为 rejected 时的回调。 123456789101112131415161718/* 使用模块 */import &#123; get &#125; from &#x27;./util&#x27;;const btn = () =&gt; &#123; const handleClick = () =&gt; &#123; get(&#x27;https://api.apiopen.top/getJoke&#x27;) .then( value =&gt; console.log(value), ) .catch( err =&gt; console.log(err) ); &#125;; return ( &lt;button onClick=&#123;handleClick&#125;&gt;发送请求&lt;/button&gt; );&#125;;export default btn; Promise.resolve 和 Promise.reject创建一个状态属性取值为成功或失败的 promise 对象，结果值为调用时传入的参数。 12let p1 = Promise.resolve(200);let p2 = Promise.reject(404); Tips: 对于 Promise.resolve ，如果传入的是一个 promise 对象，那么返回的 promise 对象 的状态和结果这个 传入的 promise 对象决定。 对于 Promise.reject ，如果传入的是一个 promise 对象，那么返回的 promise 对象 的状态始终为失败，并且结果就是传入的这个 promise 对象 数据。 Promise.all(promises) =&gt; &#123;&#125; 传入的参数是一个 存储 promise 对象的数组，返回值是一个 新的 promise 对象，只有数组中所有的 promise 对象 为成功状态时，这个 新的 promise 对象 的状态才为成功，只要数组中有一个 promise 对象 状态为失败，则 新的 promise 对象 的状态就为失败。如果 promise 对象数组 中所有 promise 对象 状态都为成功，则 新 promise 对象 的结果为 所有成功 promise 对象结果 构成的数组。 1234567let p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;success&#x27;);&#125;);let p2 = Promise.resolve(202);let p3 = Promise.resolve(203);const result = Promise.all([p1, p2, p3]); Promise.race(promises) =&gt; &#123;&#125; 用法于 Promise.all 相似，不同的是返回的 新的 promise 对象 的状态和结果，由 promise 对象数组 中第一个改变状态的 promise 对象 决定。 1234567891011let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&quot;OK&quot;); &#125;, 1000);&#125;);let p2 = Promise.reject(202);let p3 = Promise.reject(203);// 第一个改变状态的 promise 对象是 p2const result = Promise.race([p1, p2, p3]); Promise 关键细节修改 promise 对象状态的方式 在 excutor 内部调用 resolve ，可以使 promise 对象状态 由 pending 变为 resovled (fullfilled)。 在 excutor 内部调用 reject ，可以使 promise 对象状态 由 pending 变为 rejected。 在 excutor 内部 throw 异常，可以使 promise 对象状态 由 pending 变为 rejected。 为 promise 对象指定多个回调前文中说过，只要 promise 对象 发生了改变，那么就会去执行对应的回调，那么对于某种改变的可能，为其设置多个回调，会都进行调用吗？答案是可以的，并且回调的执行顺序就是绑定回调的顺序。 12345678910111213const p = new Promise((resolve, reject) =&gt; &#123; resolve(200);&#125;);// 先弹框p.then(() =&gt; &#123; alert(123);&#125;);// 弹框消失后再打印p.then(() =&gt; &#123; console.log(123);&#125;); promise 对象改变状态和绑定回调执行顺序123456let p = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;OK&#x27;); // 这里理解为改变 promise 对象的代码，先不讨论同步或异步&#125;).then(value =&gt; &#123; &#125;); 这里探讨的问题就是，上面代码中，第 2 行代码 和 第 4 行代码 谁先执行？答案是都有可能。 先执行 resolve 改变状态再执行 then 方法绑定回调：excutor 内部是通过同步任务来改变 promise 对象 状态的，那么就会先执行改变状态的代码，再通过 then 方法绑定回调。 先执行 then 方法绑定回调再执行 resolve 改变状态：excutor 内部是通过异步任务来改变 promise 对象 状态的，那么就会先进行回调绑定，再执行改变状态的代码。 then 方法调用返回结果的特点上文说过，promise 对象 调用完 then 方法后，会返回一个 新的 promise 对象，那么这个 新 promise 对象 的 状态 和 结果 由什么决定呢？答案是由 then 指定的回调函数执行的结果 (return / throw) 决定，看看下面的例子。 12345678910111213const p = new Promise((resolve, reject) =&gt; &#123; // resolve(123); // reject(123);&#125;);const newP = p.then( value =&gt; &#123; return value; &#125;, reason =&gt; &#123; throw reason; &#125;); 在 then 方法绑定的回调中： return 的是 非 promise 对象 的任意值，那么 新的 promise 对象 状态变为 resolved，结果为返回的值。 return 的是 promise 对象，那么 新的 promise 对象 状态和结果由此 promise 对象 决定。 throw 异常，那么 新的 promise 对象 状态变为 rejected，结果为抛出的异常。 串联多个任务场景：有五个异步任务，当上一个异步任务执行完毕后，间隔 1s 再执行下一个异步任务。 12345678910111213141516/* 不使用 Promise 产生的回调地狱 */setTimeout(() =&gt; &#123; console.log(1); setTimeout(() =&gt; &#123; console.log(2); setTimeout(() =&gt; &#123; console.log(3); setTimeout(() =&gt; &#123; console.log(4); setTimeout(() =&gt; &#123; console.log(5); &#125;, 1000); &#125;, 1000); &#125;, 1000); &#125;, 1000)&#125;, 1000); 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* 使用 Promise 解决了回调地狱问题 */const p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(1); console.log(p); resolve(1); &#125;, 1000);&#125;).then(value =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(++value); console.log(p); resolve(value); &#125;, 1000); &#125;);&#125;).then(value =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(++value); console.log(p); resolve(value); &#125;, 1000); &#125;);&#125;).then(value =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(++value); console.log(p); resolve(value); &#125;, 1000); &#125;);&#125;).then(value =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(++value); console.log(p); resolve(value); &#125;, 1000); &#125;);&#125;); 思考： 1234567891011const p = new Promise((resolve, reject) =&gt; &#123; resolve(123);&#125;).then(value =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; resolve(value); &#125;);&#125;).then(value =&gt; &#123; console.log(value); // 123&#125;).then(value =&gt; &#123; console.log(value); // undefined&#125;); 为什么第二次打印为 undefined ？因为在第二次调用 then 方法绑定回调的时候，默认返回值为 undefined ，所以第二次调用完 then 方法后返回的 promise 对象 的状态为成功，并且保存的结果为 undefined ，那么执行第三次调用 then 方法的时候，会立刻执行里面绑定的回调，打印成功状态的结果，即 undefined 。 Promise 异常穿透当任务失败的时候，我们可以将 catch 放到最后来处理异常。 1234567891011const p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;err&#x27;) &#125;);&#125;).then(value =&gt; &#123; console.log(1);&#125;).then(value =&gt; &#123; console.log(2);&#125;).catch(reason =&gt; &#123; console.log(reason);&#125;); 中断 Promise 链123456789101112131415const p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;err&#x27;) &#125;);&#125;).then(value =&gt; &#123; console.log(1);&#125;).then(value =&gt; &#123; console.log(2);&#125;).then(value =&gt; &#123; console.log(3);&#125;).then(value =&gt; &#123; console.log(4);&#125;).catch(reason =&gt; &#123; console.log(reason);&#125;); 现在要求只打印出 1、2，即中断第三个 then 方法后面的回调执行。只需要在第二个 then 方法绑定的回调中返回一个 pending 状态的 promise 对象 即可。 12345678910111213141516const p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;err&#x27;) &#125;);&#125;).then(value =&gt; &#123; console.log(1);&#125;).then(value =&gt; &#123; console.log(2);+ return new Promise(() =&gt; &#123;&#125;); &#125;).then(value =&gt; &#123; console.log(3);&#125;).then(value =&gt; &#123; console.log(4);&#125;).catch(reason =&gt; &#123; console.log(reason);&#125;); Promise 自定义封装本节我们将会通过 原生 JavaScript 封装实现 Promise 相关功能。 async 与 awaitasync 函数： 函数的返回值为 promise 对象。 返回的 promise 对象 的 结果和状态 由 async 函数 执行结果决定。 规则如下： return 的是 非 promise 对象 的任意值，那么 新的 promise 对象 状态变为 resolved，结果为返回的值。 return 的是 promise 对象，那么 新的 promise 对象 状态和结果由此 promise 对象 决定。 throw 异常，那么 新的 promise 对象 状态变为 rejected，结果为抛出的异常。 12345678910111213141516171819202122async function fn1() &#123; return &#x27;success&#x27;;&#125;// 返回状态为 resolved、结果为 success 的 promise 对象console.log(fn1()); async function fn2() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;err&#x27;); &#125;, 1000); &#125;);&#125;// 先是返回一个状态为 pending、结果为 undefined 的 promise 对象// 一秒后这个 promise 对象状态变为 rejected、结果为 errconsole.log(fn2());async function fn3() &#123; throw &#x27;err&#x27;;&#125;// 返回状态为 rejected、结果为 err 的 promise 对象console.log(fn3()); await 表达式： await 修饰的对象一般为 promise 对象，但也可以是其它值。 如果 await 修饰的是 promise 对象，那么整个表达式返回 promise 对象 的结果值。 如果 await 修饰的是其它值，则整个表达式返回的结果就是该修饰的值。 Tips： await 必须写在 async 函数中 如果 await 修饰的 promise 对象 结果为失败，则整个表达式会抛出异常，需要通过 try ... catch ... 处理 12345678910111213async function fn2() &#123; let result1 = await Promise.resolve(123); console.log(result1); try &#123; let result2 = await Promise.reject(&#x27;err&#x27;); // 上面的代码抛出异常后不会在继续执行下一行的代码 console.log(result2); &#125; catch(reason) &#123; console.log(reason); &#125;&#125;fn2(); 实践： 结合使用前文使用 Promise 封装的 AJAX 请求。 123456789101112131415161718/* 封装 AJAX */export function get(url) &#123; return new Promise((resolve, reject) =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.responseType = &#x27;json&#x27;; xhr.open(&#x27;GET&#x27;, url); xhr.send(); xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState === 4) &#123; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123; resolve(xhr.response) &#125; else &#123; reject(xhr.response); &#125; &#125; &#125; &#125;);&#125;; 123456789101112131415import &#123; get &#125; from &#x27;./util&#x27;;const btn = () =&gt; &#123; const handleClick = async () =&gt; &#123; try &#123; let data = await get(&#x27;https://api.apiopen.top/getJoke&#x27;); console.log(data); &#125; catch(reason) &#123; console.log(reason); &#125; &#125;; return ( &lt;button onClick=&#123;handleClick&#125;&gt;发送请求&lt;/button&gt; );&#125;;export default btn;","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://yukee-798.github.io/tags/Web/"},{"name":"Async","slug":"Async","permalink":"https://yukee-798.github.io/tags/Async/"}]},{"title":"Hello Hexo!","slug":"Hexo-的常用指令","date":"2021-02-08T13:28:11.000Z","updated":"2021-02-14T15:46:43.000Z","comments":true,"path":"2021/02/08/Hexo-的常用指令/","link":"","permalink":"https://yukee-798.github.io/2021/02/08/Hexo-%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/","excerpt":"","text":"一、常用命令1.1 获取管理员权限1$ sudo su 1.2 初始化博客配置1$ sudo hexo init 使用管理员权限初始化 1.3 创建一篇新文章1$ hexo new &quot;My New Post&quot; 1.4 生成静态文件1$ hexo g 配置完 config，或者新建一篇文章…等修改了文件操作需要使用一下该指令 1.5 本地预览1$ hexo s 1.6 推送到远端1$ hexo d 二、配置主题主题可以自己去 github 上找，下面以 hexo-theme-yilia 为例。先将其 clone 到 myBlog 的 themes 文件夹下面。然后修改 _config.yml 配置文件，找到 theme，修改为对应的文件夹名称即可！其余配置可以参考对应主题的 readme 使用。 关于修改主题的配置文件：其内部默认的相对根目录为 public","categories":[],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://yukee-798.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}],"categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://yukee-798.github.io/tags/Web/"},{"name":"Taro","slug":"Taro","permalink":"https://yukee-798.github.io/tags/Taro/"},{"name":"Redux-Saga","slug":"Redux-Saga","permalink":"https://yukee-798.github.io/tags/Redux-Saga/"},{"name":"VScode","slug":"VScode","permalink":"https://yukee-798.github.io/tags/VScode/"},{"name":"Reg","slug":"Reg","permalink":"https://yukee-798.github.io/tags/Reg/"},{"name":"Sass","slug":"Sass","permalink":"https://yukee-798.github.io/tags/Sass/"},{"name":"Ant_Design","slug":"Ant-Design","permalink":"https://yukee-798.github.io/tags/Ant-Design/"},{"name":"React","slug":"React","permalink":"https://yukee-798.github.io/tags/React/"},{"name":"yk-design","slug":"yk-design","permalink":"https://yukee-798.github.io/tags/yk-design/"},{"name":"NodeJS","slug":"NodeJS","permalink":"https://yukee-798.github.io/tags/NodeJS/"},{"name":"Axios","slug":"Axios","permalink":"https://yukee-798.github.io/tags/Axios/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://yukee-798.github.io/tags/TypeScript/"},{"name":"Webpack","slug":"Webpack","permalink":"https://yukee-798.github.io/tags/Webpack/"},{"name":"Plan","slug":"Plan","permalink":"https://yukee-798.github.io/tags/Plan/"},{"name":"Async","slug":"Async","permalink":"https://yukee-798.github.io/tags/Async/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://yukee-798.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}